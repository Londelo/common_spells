import fs from 'fs'
import path from 'path'
import os from 'os'
import { echo } from 'shelljs'
import { execute } from '../shell'
import { green, yellow, red, cyan } from '../colors'
import { readBedrockConfig, validateDockerEnvironment } from './helpers'
import { DCC_DIR } from './types'

// --- Types ---

type CheckResult = {
  readonly label: string
  readonly status: 'ok' | 'warn' | 'error'
  readonly details: readonly string[]
}

type SetupReport = {
  readonly checks: readonly CheckResult[]
  readonly environment: Record<string, string>
}

// --- TechPass Check ---

const checkTechPass = async (): Promise<CheckResult> => {
  try {
    const whichCommand = 'which tech-pass'
    echo(yellow(whichCommand))
    await execute(whichCommand, 'TechPass lookup')
  } catch {
    return {
      label: 'TechPass',
      status: 'warn',
      details: [
        'TechPass not found in PATH',
        'Install from: https://confluence.livenation.com/spaces/TOP/pages/204166978/Tech+Pass',
      ],
    }
  }

  try {
    const versionCommand = 'tech-pass version 2>/dev/null'
    echo(yellow(versionCommand))
    const versionOutput = await execute(versionCommand, 'TechPass version')
    const versionMatch = versionOutput.match(/(\d+\.\d+\.\d+)/)
    const version = versionMatch ? versionMatch[1] : null

    if (!version) {
      return {
        label: 'TechPass',
        status: 'warn',
        details: ['Could not determine TechPass version'],
      }
    }

    const meetsMinimum = compareVersions(version, '5.3.0') >= 0

    return meetsMinimum
      ? { label: 'TechPass', status: 'ok', details: [`Version: ${version}`] }
      : {
          label: 'TechPass',
          status: 'error',
          details: [
            `Version ${version} found — requires 5.3.0+`,
            'Update: https://confluence.livenation.com/spaces/TOP/pages/204166978/Tech+Pass',
          ],
        }
  } catch {
    return {
      label: 'TechPass',
      status: 'warn',
      details: ['Could not determine TechPass version'],
    }
  }
}

const compareVersions = (a: string, b: string): number => {
  const partsA = a.split('.').map(Number)
  const partsB = b.split('.').map(Number)
  const maxLen = Math.max(partsA.length, partsB.length)

  return Array.from({ length: maxLen }).reduce<number>((result, _, i) => {
    if (result !== 0) return result
    const diff = (partsA[i] ?? 0) - (partsB[i] ?? 0)
    return diff
  }, 0)
}

// --- Claude Settings Check ---

const checkClaudeSettings = (): CheckResult => {
  const settingsPath = path.join(os.homedir(), '.claude', 'settings.json')

  if (!fs.existsSync(settingsPath)) {
    return {
      label: 'Claude Settings',
      status: 'error',
      details: [
        `Not found: ${settingsPath}`,
        'This file is auto-generated by TechPass when you:',
        '  1. Have TechPass v5.3.0+',
        '  2. Are in the Claude Code AD group',
        '  3. Sign in via TechPass',
        'Request access: https://adaxes.techops.info/Adaxes/AdaxesSelfService#/',
      ],
    }
  }

  try {
    const raw = fs.readFileSync(settingsPath, 'utf-8')
    JSON.parse(raw)
    return {
      label: 'Claude Settings',
      status: 'ok',
      details: [`Found: ${settingsPath}`],
    }
  } catch {
    return {
      label: 'Claude Settings',
      status: 'warn',
      details: [`Found but invalid JSON: ${settingsPath}`],
    }
  }
}

// --- AWS Credentials Check ---

const checkAwsCredentials = (): CheckResult => {
  const awsDir = path.join(os.homedir(), '.aws')

  if (!fs.existsSync(awsDir)) {
    return {
      label: 'AWS Credentials',
      status: 'warn',
      details: [
        `AWS config not found at ${awsDir}`,
        'This may be OK if TechPass handles authentication',
      ],
    }
  }

  const details: string[] = [`Found: ${awsDir}`]

  const credentialsFile = path.join(awsDir, 'credentials')
  if (fs.existsSync(credentialsFile)) {
    try {
      const raw = fs.readFileSync(credentialsFile, 'utf-8')
      const profiles = raw
        .split('\n')
        .filter((line: string) => line.match(/^\[.+\]$/))
        .map((line: string) => line.replace(/[[\]]/g, ''))
      details.push(`Profiles: ${profiles.join(', ') || 'default'}`)
    } catch {
      details.push('Could not read credentials file')
    }
  }

  const configFile = path.join(awsDir, 'config')
  if (fs.existsSync(configFile)) {
    try {
      const raw = fs.readFileSync(configFile, 'utf-8')
      const hasSso = raw.includes('sso_')
      details.push(`SSO configured: ${hasSso ? 'yes' : 'no'}`)
    } catch {
      // Ignore config read failures
    }
  }

  return { label: 'AWS Credentials', status: 'ok', details }
}

// --- Docker Check ---

const checkDocker = async (): Promise<CheckResult> => {
  try {
    const dockerVersionCommand = 'docker --version 2>/dev/null'
    echo(yellow(dockerVersionCommand))
    const versionOutput = await execute(dockerVersionCommand, 'Docker version')
    const versionMatch = versionOutput.match(/(\d+\.\d+)/)
    const version = versionMatch ? versionMatch[1] : 'unknown'

    try {
      const sandboxHelpCommand = 'docker sandbox --help 2>/dev/null'
      echo(yellow(sandboxHelpCommand))
      await execute(sandboxHelpCommand, 'Docker sandbox check')
      return {
        label: 'Docker',
        status: 'ok',
        details: [`Version: ${version}`, 'Sandbox support: yes'],
      }
    } catch {
      return {
        label: 'Docker',
        status: 'warn',
        details: [
          `Version: ${version}`,
          'Sandbox support: no',
          'Update Docker Desktop to v29+ for sandbox support',
        ],
      }
    }
  } catch {
    return {
      label: 'Docker',
      status: 'error',
      details: [
        'Docker not found',
        'Install Docker Desktop: https://www.docker.com/products/docker-desktop',
      ],
    }
  }
}

// --- Bedrock Config Check ---

const checkBedrockConfig = (): { readonly check: CheckResult; readonly env: Record<string, string> } => {
  const config = readBedrockConfig()
  const env: Record<string, string> = {}
  const details: string[] = []

  if (config.bedrockEnabled) {
    env['CLAUDE_CODE_USE_BEDROCK'] = config.bedrockEnabled
    details.push(`CLAUDE_CODE_USE_BEDROCK=${config.bedrockEnabled}`)
  }

  env['AWS_REGION'] = config.awsRegion
  details.push(`AWS_REGION=${config.awsRegion}`)

  if (config.awsProfile) {
    env['AWS_PROFILE'] = config.awsProfile
    details.push(`AWS_PROFILE=${config.awsProfile}`)
  }

  if (config.model) {
    env['ANTHROPIC_MODEL'] = config.model
    details.push(`ANTHROPIC_MODEL=${config.model}`)
  }

  env['DCC_DIR'] = DCC_DIR
  details.push(`DCC_DIR=${DCC_DIR}`)

  return {
    check: {
      label: 'Environment Variables',
      status: config.bedrockEnabled ? 'ok' : 'warn',
      details: details.length > 0 ? details : ['No Bedrock configuration detected'],
    },
    env,
  }
}

// --- Display ---

const statusIcon = (status: 'ok' | 'warn' | 'error'): string => {
  const icons: Record<string, string> = { ok: '✓', warn: '⚠', error: '✗' }
  return icons[status]
}

const statusColor = (status: 'ok' | 'warn' | 'error', text: string): string => {
  const colorFns: Record<string, (t: string) => string> = { ok: green, warn: yellow, error: red }
  return colorFns[status](text)
}

const printCheck = (result: CheckResult): void => {
  echo(statusColor(result.status, `${statusIcon(result.status)} ${result.label}`))
  result.details.forEach((detail: string) => echo(`  ${detail}`))
  echo('')
}

const printSummary = (report: SetupReport): void => {
  const errors = report.checks.filter((c: CheckResult) => c.status === 'error')
  const warns = report.checks.filter((c: CheckResult) => c.status === 'warn')

  if (errors.length === 0 && warns.length === 0) {
    echo(green('=== Setup Complete ==='))
    echo('')
    echo('Your environment is ready. You can now run:')
  } else if (errors.length === 0) {
    echo(yellow('=== Setup Complete (with warnings) ==='))
    echo('')
    echo('Your environment may work, but some issues were detected.')
  } else {
    echo(red('=== Setup Incomplete ==='))
    echo('')
    echo('Some required components are missing. Fix the errors above before proceeding.')
    return
  }

  echo('')
  echo('  # Single agent (interactive)')
  echo(`  dcc-run ~/your-project`)
  echo('')
  echo('  # Single agent (headless)')
  echo(`  dcc-run -p "Your task" ~/your-project`)
  echo('')
}

// --- Main Entry Point ---

const dccSetup = async (): Promise<SetupReport> => {
  echo(cyan('=== Docker Claude Code Setup ==='))
  echo('')

  const techPass = await checkTechPass()
  printCheck(techPass)

  const claudeSettings = checkClaudeSettings()
  printCheck(claudeSettings)

  const awsCreds = checkAwsCredentials()
  printCheck(awsCreds)

  const docker = await checkDocker()
  printCheck(docker)

  const { check: envCheck, env } = checkBedrockConfig()
  printCheck(envCheck)

  const report: SetupReport = {
    checks: [techPass, claudeSettings, awsCreds, docker, envCheck],
    environment: env,
  }

  printSummary(report)

  return report
}

export default dccSetup
